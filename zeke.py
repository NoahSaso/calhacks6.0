# Defines a function to encode text in an image using LSB encoding.
# Made with much inspiration from https://github.com/cedricbonhomme/Stegano
from utils import readImage, bits_list, setLSB

def encode(filepath, message):
    msg_len = len(message)
    assert msg_len != 0, "You probably didn't mean to do this."

    the_image = readImage(filepath);
    encoded = the_image.copy()
    assert the_image.mode == "RGB", "Non RGB images are not supported."

    bits_per_color = the_image.bits
    width, height = the_image.size

    # Encode the length of the message first.
    message = str(msg_len) + ":" + str(message)
    message_bits = "".join(bits_list(message))
    message_bits += "0" * ((3 - (len(message_bits) % 3)) % 3)

    pixel_count = width*height
    msg_bit_count = len(message_bits)

    assert pixel_count > 3 * msg_bit_count, "Message is too big for image."
    
    # Move through image modifying lsb of each color value to store
    # image. Later this will need to be more careful about how it
    # chooses indicies likely generated by a their password argument.
    index = 0
    for row in range(height):
        for col in range(width):
            if index + 3 <= msg_bit_count:
                r, g, b = the_image.getpixel((col, row))
                r = setLSB(r, message_bits[index])
                g = setLSB(g, message_bits[index + 1])
                b = setLSB(b, message_bits[index + 2])
                encoded.putpixel((col, row), (r, g, b))
                index += 3
            else:
                the_image.close()
                return encoded

# TODO(zeke): This is much like paraglob. We've defined the encoding
# to be <number> : <body>, as such, we just look for the first
# :. There is room to make this more accurate as a message can only be
# as long as a third of the image length.
#
# Should read until we hit a :. The characters before that should all
# be numbers. These are the number of bits to be read. Cool.
# Credit: https://github.com/cedricbonhomme/Stegano/blob/master/stegano/lsb/lsb.py
def decode(img):
#    img = readImage(fileName)
    width, height = img.size
    buff, count = 0, 0
    bitab = []
    limit = None
    for row in range(height):
        for col in range(width):
            pixel = img.getpixel((col, row))
            for color in pixel:
                buff += (color & 1) << (8 - 1 - count)
                count += 1
                if count == 8:
                    bitab.append(chr(buff))
                    buff, count = 0, 0
                    if bitab[-1] == ":" and limit is None:
                        try:
                            limit = int("".join(bitab[:-1]))
                        except:
                            pass

            if len(bitab) - len(str(limit)) - 1 == limit:
                img.close()
                return "".join(bitab)[len(str(limit)) + 1 :]

print( decode(encode("web/styles/pooh.jpeg", "I love dogs")) )
